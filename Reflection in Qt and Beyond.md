---
<!-- marp: true -->
---

<!-- $theme: default -->

Reflection in Qt and Beyond
===

![](images/qt.jpg)![](images/qt-rev.jpg)

##### [Auckland C++ Meetup](https://www.meetup.com/Auckland-C-Meetup/)

###### Presented by Tom Isaacson ( [@parsley72](https://twitter.com/parsley72) )

---

![](images/Qt_20years_infographic_big.jpg)

---
<!-- page_number: true -->

# Qt Introduction

* Used for developing graphical user interfaces (GUIs) and multi-platform applications.
* Non-GUI programs can be also developed, such as command-line tools and consoles for servers.
* Runs on all major desktop platforms and most mobile or embedded platforms.
* Supports various compilers, including the GCC C++ compiler and the Visual Studio suite and has extensive internationalization support.
* Qt also provides Qt Quick, that includes a declarative scripting language called QML that allows using JavaScript to provide the logic.
* Other features include SQL database access, XML parsing, JSON parsing, thread management and network support.

---

# Qt Rough Guide

The QObject class is the base class of all Qt objects.

QObject is the heart of the Qt Object Model. The central feature in this model is a very powerful mechanism for seamless object communication called signals and slots. You can connect a signal to a slot with connect() and destroy the connection with disconnect(). To avoid never ending notification loops you can temporarily block signals with blockSignals(). The protected functions connectNotify() and disconnectNotify() make it possible to track connections.

QObjects organize themselves in object trees. When you create a QObject with another object as parent, the object will automatically add itself to the parent's children() list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using findChild() or findChildren().

---

# [Using the Meta-Object Compiler (moc)](https://doc.qt.io/qt-5.11/moc.html)

The Meta-Object Compiler, moc, is the program that handles Qt's C++ extensions.

The moc tool reads a C++ header file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces a C++ source file containing the meta-object code for those classes. Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.

The C++ source file generated by moc must be compiled and linked with the implementation of the class.

If you use qmake to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on moc, see Why Does Qt Use Moc for Signals and Slots?

---

# [Why Does Qt Use Moc for Signals and Slots?](https://doc.qt.io/qt-5.11/why-moc.html)

Templates are a builtin mechanism in C++ that allows the compiler to generate code on the fly, depending on the type of the arguments passed. As such, templates are highly interesting to framework creators, and we do use advanced templates in many places in Qt. However, there are limitations: There are things that you can easily express with templates, and there are things that are impossible to express with templates. A generic vector container class is easily expressible, even with partial specialisation for pointer types, while a function that sets up a graphical user interface based on an XML description given as a string is not expressible as a template. And then there is a gray area in between. Things that you can hack with templates at the cost of code size, readability, portability, usability, extensability, robustness and ultimately design beauty. Both templates and the C preprocessor can be stretched to do incredibility smart and mind boggling things. But just because those things can be done, it does not necessarily mean doing them is the right design choice. Code, unfortunately, is not meant to be published in books, but compiled with real-world compilers on real-world operating systems.

---

### Legacy code

```cpp
class tColoredObject : public QObject
{
    Q_OBJECT

public:
    enum eColor
    {
        ColorRed = 1,
        ColorBlue = 2,
        ColorGreen = 3
    };

    tColoredObject() : m_color(ColorRed) {}

private:
    eColor m_color;
};

Q_DECLARE_METATYPE(tColoredObject::eColor);

int main()
{
    qRegisterMetaType(tColoredObject::eColor);
    ...
}

void HandleColor(tColoredObject::eColor color)
{
    switch (color)
    {
        case ColorRed: qDebug("Red"); break;
        case ColorBlue: qDebug("Blue"); break;
        case ColorGreen: qDebug("Green"); break;
        default: assert(0);
    }
}

```

---

# Enum Class

We can replace `enum` with `enum class` which improves the type safety. If we turn on [C4062](https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4062) in Visual Studio (which is on by default in GCC) we get a warning if an enum class enumerator isn't handled in a switch statement. This is useful to spot where new enumerators need to be handled so we can change the code to:

```cpp
class tColoredObject : public QObject
{
    Q_OBJECT

public:
    enum class eColor
    {
        ColorRed = 1,
        ColorBlue = 2,
        ColorGreen = 3
    };

    tColoredObject() : m_color(eColor::Red) {}

private:
    eColor m_color;
};

Q_DECLARE_METATYPE(tColoredObject::eColor);

int main()
{
    qRegisterMetaType(tColoredObject::eColor);
    ...
}

void HandleColor(tColoredObject::eColor color)
{
    switch (color)
    {
        case eColor::Red: qDebug("Red"); break;
        case eColor::Blue: qDebug("Blue"); break;
        case eColor::Green: qDebug("Green"); break;
    }
}
```

<!-- But this means the assert we get if the enum class is an undefined value has gone so it's not an exact replacement. -->

---

# Q_ENUM

I was looking into this and I found [New in Qt 5.5: Q_ENUM and the C++ tricks behind it](https://woboq.com/blog/q_enum.html). This explains the new [Q_ENUM()](https://doc.qt.io/qt-5/qobject.html#Q_ENUM) which replaces Q_DECLARE_METATYPE() for enums and removes the need to call qRegisterMetaType():

```cpp
class tColoredObject : public QObject
{
    Q_OBJECT

public:
    enum class eColor
    {
        ColorRed = 1,
        ColorBlue = 2,
        ColorGreen = 3
    };
    Q_ENUM(eColor)

    tColoredObject() : m_color(eColor::Red) {}

private:
    eColor m_color;
};
```

---

This is great, but it also means you can use Qt's reflection. I've added `AssertIfValueIsOutsideQEnumRange()` which asserts if the enum class value is undefined:

```cpp
template <typename T, typename V>
void AssertIfValueIsOutsideQEnumRange(V val)
{
    const QMetaEnum metaEnum = QMetaEnum::fromType<T>();
    const int nVal = static_cast<int>(val);
    const char* keyStr = metaEnum.valueToKey(nVal);
    if (keyStr == nullptr)
    {
        const QString output =
            QString("AssertIfValueIsOutsideQEnumRange(%1): outside range of %2::%3").arg(nVal).arg(metaEnum.scope()).arg(metaEnum.name());
        qDebug(output);
    }
    assert(keyStr != nullptr);
}
```

We can use this to recreate the assert we removed from the switch:

```cpp
void HandleColor(tColoredObject::eColor color)
{
    switch (color)
    {
        case eColor::Red: qDebug("Red"); break;
        case eColor::Blue: qDebug("Blue"); break;
        case eColor::Green: qDebug("Green"); break;
    }
    AssertIfValueIsOutsideQEnumRange<tColoredObject::eColor>(color);
}
```

---

```cpp
#include <boost/static_assert.hpp>

//-----------------------------------------------------------------------------
//! Base template function definition for the Minimum range of an enum of type T.
//! It is expected that the enum shall provide a total template specialization
//! for the enum of type T, so this function should not be called.
//-----------------------------------------------------------------------------
template <typename T>
T EnumRangeMin()
{
    BOOST_STATIC_ASSERT_MSG(sizeof(T) == 0, "EnumRangeMin - No template specialization for the EnumRangeMin function for the given enum");

    // If you receive this compile time message it means you need to supply a template specialization
    // for the enum type for which you tried to call 'ConvertIntToEnumLinearRange' e.g.:
    // template<> eMyEnum EnumRangeMin<eMyEnum>() {return eMinValueForMyEnum;}

    return static_cast<T>(0);
}

//-----------------------------------------------------------------------------
//! Base template function definition the Maximum range of the enum of type T.
//! It is expected that the enum shall provide a total template specialization
//! for the enum of type T, so this function should not be called.
//-----------------------------------------------------------------------------
template <typename T>
T EnumRangeMax()
{
    BOOST_STATIC_ASSERT_MSG(sizeof(T) == 0, "EnumRangeMax - No template specialization for the EnumRangeMax function for the given enum");

    // If you receive this compile time message it means you need to supply a template specialization
    // for the enum type for which you tried to call 'ConvertIntToEnumLinearRange' e.g.:
    // template<> eMyEnum EnumRangeMax<eMyEnum>() {return eMaxValueForMyEnum;}
    return static_cast<T>(0);
}
```

---

```cpp
namespace
{
//-----------------------------------------------------------------------------
//! Function to convert a value (of unspecified type) to an enum. The value to be converted
//! must lie within an enum linear range where:
//! EnumRangeMin<T>() <= \a val <= EnumRangeMax<T>()
//! If the value that is supplied does not lie within the range the result is either
//! the minimum (when too small) or maximum (when too large) range value of the enum.
//-----------------------------------------------------------------------------
template <typename T, typename V>
T ConvertValueToEnumLinearRange(V val)
{
    // If the value is outside the linear range then, we constrain the result to either min or max
    T minRange = EnumRangeMin<T>();
    if (val < static_cast<V>(minRange))
        return minRange;

    T maxRange = EnumRangeMax<T>();
    if (val > static_cast<V>(maxRange))
        return maxRange;

    // The value exists within the range, so provide the converted the value
    return static_cast<T>(val);
}
} // namespace

//-----------------------------------------------------------------------------
//! Function to convert an int (or any value that provides an implicit conversion
//! to an int) to an enum. This is a specialization
//! of the more general ConvertValueToEnumLinearRange<T,V> function template to ensure
//! that only integral values offer a conversion.
//-----------------------------------------------------------------------------
template <typename T>
T ConvertIntToEnumLinearRange(int val)
{
    return ConvertValueToEnumLinearRange<T, int>(val);
}
```
---

```cpp
enum class eThingType
{
    None,
    Possum,
    Banana
};

template <>
eThingType EnumRangeMin<eThingType>();
template <>
eThingType EnumRangeMax<eThingType>();

//! Convert an eThingType to a string representation.
QString ThingTypeEnumToString(eThingType thingType);
```

```cpp
template <>
eThingType EnumRangeMin<eThingType>()
{
    return eThingType::None;
}
template <>
eThingType EnumRangeMax<eThingType>()
{
    return eThingType::Banana;
}

QString ThingTypeEnumToString(eThingType thingType)
{
    QString str;

    switch (thingType)
    {
    case eThingType::None:
    {
        str = "None";
    }
    break;
    case eThingType::Possum:
    {
        str = "Possum";
    }
    break;
    case eThingType::Banana:
    {
        str = "Banana";
    }
    break;
    }

    return str;
}
```

---

```cpp
#include <boost/optional.hpp>

//-----------------------------------------------------------------------------
//! Function to convert an enum value to a QString. The enum must be declared as Q_ENUM.
//-----------------------------------------------------------------------------
template <typename T, typename V>
QString ConvertQEnumValueToString(V val)
{
    const QMetaEnum metaEnum = QMetaEnum::fromType<T>();
    const char* str = metaEnum.valueToKey(static_cast<int>(val));
    return QString::fromUtf8(str);
}

namespace
{
//-----------------------------------------------------------------------------
//! Function to convert a value (of unspecified type) to an enum. The enum must be declared as Q_ENUM.
//! The value to be converted must lie within the enum range.
//! If the value that is supplied does not lie within the range the result is either
//! the minimum (when too small) or maximum (when too large) range value of the enum.
//! If the value is within the range but does not match an enum value the return is boost::none.
//-----------------------------------------------------------------------------
template <typename T, typename V>
boost::optional<T> ConvertValueToQEnumRange(V val)
{
    const QMetaEnum metaEnum = QMetaEnum::fromType<T>();
    const char* keyStr = metaEnum.valueToKey(val);
    if (keyStr != nullptr)
    {
        return static_cast<T>(val);
    }

    // There's no guarantee the enum values are in numerical order
    static int minVal = std::numeric_limits<int>::max();
    static int maxVal = std::numeric_limits<int>::min();
    if ((minVal == std::numeric_limits<int>::max()) && (maxVal == std::numeric_limits<int>::min()))
    {
        const int keyCount = metaEnum.keyCount();
        for (int key = 0; key < keyCount; ++key)
        {
            const int value = metaEnum.value(key);
            minVal = std::min(value, minVal);
            maxVal = std::max(value, maxVal);
        }
    }

    const char* minKey = metaEnum.valueToKey(minVal);
    const int min = metaEnum.keyToValue(minKey);
    if (val < min)
    {
        // Return the min value
        return static_cast<T>(min);
    }

    const char* maxKey = metaEnum.valueToKey(maxVal);
    const int max = metaEnum.keyToValue(maxKey);
    if (val > max)
    {
        // Return the max value
        return static_cast<T>(max);
    }

    // Not out of range, but invalid enum value
    return boost::none;
}
} // namespace

//-----------------------------------------------------------------------------
//! Function to check a value (of unspecified type) is in the range of an enum. The enum must be declared as Q_ENUM.
//! If the value that is supplied does not lie within the range an assert is triggered.
//-----------------------------------------------------------------------------
template <typename T, typename V>
void AssertIfValueIsOutsideQEnumRange(const char* pFile, int line, V val, const char* message = nullptr)
{
    const QMetaEnum metaEnum = QMetaEnum::fromType<T>();
    const int nVal = static_cast<int>(val);
    const char* keyStr = metaEnum.valueToKey(nVal);
    if (keyStr == nullptr)
    {
        const QString output =
            QString("AssertIfValueIsOutsideQEnumRange(%1): outside range of %2::%3").arg(nVal).arg(metaEnum.scope()).arg(metaEnum.name());
        tDebug::DDbgPrintf(QString(), pFile, line, output);
    }
    MessageAssert(keyStr != nullptr, message);
}

//-----------------------------------------------------------------------------
//! Function to check an int is in the range of an enum. The enum must be declared as Q_ENUM.
//! This is a specialization of the more general AssertIfValueIsOutsideQEnumRange<T,V> function template to ensure that only integral values are checked.
//-----------------------------------------------------------------------------
template <typename T>
void AssertIfIntIsOutsideQEnumRange(const char* pFile, int line, int val, const char* message = nullptr)
{
    AssertIfValueIsOutsideQEnumRange<T, int>(pFile, line, val, message);
}

//-----------------------------------------------------------------------------
//! Function to convert an int (or any value that provides an implicit conversion to an int) to an enum.
//! This is a specialization of the more general ConvertValueToQEnumRange<T,V> function template to ensure that only integral values offer a conversion.
//-----------------------------------------------------------------------------
template <typename T>
boost::optional<T> ConvertIntToQEnumRange(int val)
{
    return ConvertValueToQEnumRange<T, int>(val);
}

//-----------------------------------------------------------------------------
//! Function to convert a uint (or any value that provides an implicit conversion to a uint) to an enum.
//! This is a specialization of the more general ConvertValueToQEnumRange<T,V> function template to ensure that only integral values offer a conversion.
//! Note that because ConvertValueToQEnumRange is implemented with int, any value larger than numeric_limits<int>::max() returns boost::none
//-----------------------------------------------------------------------------
template <typename T>
boost::optional<T> ConvertIntToQEnumRange(uint val)
{
    if (val > static_cast<uint>(std::numeric_limits<int>::max()))
    {
        // Can't handle an unsigned value this large
        return boost::none;
    }
    return ConvertValueToQEnumRange<T, int>(val);
}
```

---

* The Reflection TS: [wg21.link/n4746](https://wg21.link/n4746)
* Standard containers and `constexpr`: [wg21.link/p0784](https://wg21.link/p0784)
* Making `std::vector` `constexpr`: [wg21.link/p1004](https://wg21.link/p1004)
* Making `<algorithm>` `constexpr`: [wg21.link/p0202](https://wg21.link/p0202) et al
* `std::is_constant_evaluated()`: [wg21.link/p0595](https://wg21.link/p0595)
* `constexpr!` functions: [wg21.link/p1073](https://wg21.link/p1073)
* Metaclasses: [wg21.link/p0707](https://wg21.link/p0707)
* Value-based reflection: [wg21.link/p0993](https://wg21.link/p0993)
* Calling virtual functions in `constexpr`: [wg21.link/p1064](https://wg21.link/p1064)
* `try-catch` in `constexpr`: [wg21.link/p1002](https://wg21.link/p1002)

---

# Plan

1. Make (almost) all of C++ available in `constexpr`.
2. Provide a `constexpr` API to query the compiler.
3. Provide a means for modifying the AST (Abstract Syntax Tree).

---

# Step 1: Expanding `constexpr`

Necessary in order to use non-trivial data structures and execute non-trivial logic at compile time.

---

## In C++11 `constexpr` was very limited:

```cpp
constexpr std::size_t count_lower(char const* s, std::size_t count = 0)
{
    return *s == '\0' ? count
                    : 'a' <= *s && *s <= 'z'
                        ? count_lower(s + 1, count + 1)
                        : count_lower(s + 1, count);
}

static_assert(count_lower("aBCdeF") == 3), "");
```

---

## In C++14 many restrictions lifted:

```cpp
constexpr std::size_t count_lower(char const* s)
{
    std::size_t count = 0;
    for (; *s != '\0'; ++s)
    {
        if ('a' <= *s && *s <= 'z')
        {
            ++count;
        }
    }
    return count;
}

static_assert(count_lower("aBCdeF") == 3), "");
```

---

## In C++17, `constexpr` is still limited:
* No allocations.
* No try-catch.
* No virtual calls.
* No `reinterpret_cast`.

---

## This means we can't use variable-size containers:

```cpp
template <typename Predicate>
constexpr std::vector<int>
keep_if(int const* it, int const* last, Predicate pred)
{
    std::vector<int> result;
    for (; it != last; ++it)
    {
        if (pred(*it))
        {
            result.push_back(*it);
        }
    }
    return result;
}

constexpr int ints[] = {1, 2, 3, 4, 5, 6};
constexpr std::vector<int> odds = keep_if(std::begin(ints), std::end(ints), is_odd);
// doesn't work!
```

---

## We have to use fixed-size arrays, which is painful:

```cpp
template <srd::size_t K, typename Predicate>
constexpr std::vector<int, K>
keep_if(int const* it, int const* last, Predicate pred)
{
    std::vector<int, K> result;
    int* out = std::begin(result);
    for (; it != last; ++it)
    {
        if (pred(*it))
        {
            *out = *it;
        }
    }
    return result;
}

constexpr int ints[] = {1, 2, 3, 4, 5, 6};
constexpr std::vector<int, 3> odds =
    keep_if<3>(std::begin(ints), std::end(ints), is_odd);
```

---

## Enter P0784:

More `constexpr` containers
* Enables *new-expressions* in `constexpr`.
* Makes `std::allocator` usable in `constexpr`.
* Promotes some `constexpr` objects to static storage.

---

## The following becomes valid:

```cpp
constexpr int* square(int* first, int* last)
{
    std::size_t N = last - first;
    int* result = new int[N]; // <== HERE
    for (std::size_t i = 0; i != N; ++i, ++first)
    {
        result[i] = *first * *first;
    }
    return result;
}

constexpr void hello()
{
    int ints[] = {1, 2, 3, 4, 5};
    int* squared = square(std::begin(ints), std::end(ints));
    delete[] squared;
}
```

---

## Obvious next step

Make `std::vector` `constexpr`.

## But `std::vector` uses try-catch

So make try-catch `constexpr`!

(no `throw`)

---

## Enter P1002:

Try-catch blocks in `constexpr` functions

```cpp
template <std::size_t N>
constexpr std::array<int, N>
square(std::array<int, N> array, int from, int to)
{
    try {
        for (; from != to; ++from)
        {
            array.at(from) = array.at(from) * array.at(from);
        }
    } catch (std::out_of_range const& e) {
        // ...
    }
    return array;
}

// Works because we never execute a throw statement
constexpr auto OK     = square(std::array{1, 2, 3, 4}, 0, 4);
// Fails
constexpr auto NOT_OK = square(std::array{1, 2, 3, 4}, 0, 10);
```

---

## Fails when we execute the `throw` inside `array::at`:

```cpp
template <class T, std::size_t Size>
constexpr typename array<T, Size>::reference
array<T, Size>::at(std::size_t n)
{
    if (n >= Size)
        throw std::out_of_range("array::at"); // compilation error here

    return elements_[n];
}
```
So for now try-catch blocks are allowed but they're basically no-ops because throws aren't allowed. If you hit a `throw` at compile-time you just get a compiler error.

---

## Back to `std::vector`

In C++20, this will just work:

```cpp
template <typename Predicate>
constexpr std::vector<int>
keep_if(int const* it, int const* last, Predicate pred)
{
    std::vector<int> result;
    for (; it != last; ++it)
    {
        if (pred(*it))
        {
            result.push_back(*it);
        }
    }
    return result;
}

constexpr int ints[] = {1, 2, 3, 4, 5, 6};
constexpr std::vector<int> odds =
    keep_if(std::begin(ints), std::end(ints), is_odd);
```

---

## Future `constexpr` additions

* `std::string`
* `std::map` and `std::unordered_map`
* `std::optional/std::variant`?
* Math functions?

---

## Challenges

* `reinterpret_cast`, e.g. `std::string' Small Buffer Optimisation (SBO).
* non-`constexpr` builtins, e.g. `__builtin_memcpy`.
* Raw memory allocation, e.g. `malloc`.
* Other annotations, e.g. UBSan in libc++.

---

## Enter P0595:

* Add `std::is_constant_evaluated()`.
* Allows detecting whether the current function is evaluated as part of a constant expression.

---

## Another common problem

`constexpr` does not require compile-time evaluation.

Enter `constexpr!` (P1073) - "Immediate function"

```cpp
constexpr! int square(int x)
{
    return x * x;
}

constexpr int x = square(3); // OK

int y = 3;
int z = square(y); // ERROR: square(y) is not a constant expression
```
Don't exist at runtime.

---

## Summary of `constexpr` changes

* Expand `constexpr` to support more use cases.
* Allow persisting data structures to the *data segment*.
* Allow writing different code for `constexpr` and runtime when needed.
* Require compile-time evaluation with `constexpr!`

---

# Step 2: An API to speak to the compiler

We can already do some of it:
* type_traits, operators like `sizeof`

```cpp
struct Foo
{
    int x;
    int y;
};

constexpr std::size_t = sizeof(Foo);
constexpr bool is_aggregate = std::is_aggregate_v(Foo);
```

---

## But we're severely limited

Currently, limited to queries whose answer is a primitive type.

```cpp
struct Foo
{
    int x;
    int y;
};

constexpr auto members = ???; // List of Foo's members
```

---

## Enter the Reflection Technical Specification (TS): N4746

Purpose:
* Figure out what this query API should look like.
* Not the specific implementation of this API.
* For now, the API uses template metaprogramming.

---

## Example: Extracting members

```cpp
struct Foo
{
    int x;
    long y;
}

using MetaFoo = reflexpr(Foo); // Returns magic type
Using Members = std::reflect::get_data_members_t<MetaFoo>; // Another magic type

using MetaX = std::reflect::get_element_t<0, Members>; // Not an int!
constexpr bool is_public = std::reflect::is_public_v<MetaX>;

using X = std::reflect::get_reflected_type_t<Metax>; // This is int!
```

---

## Another example: Printing an `enum`

```cpp
enum class Color { RED, GREEN, BLUE, YELLOW, PURPLE };

std::ostream& operator<<(std::ostream& out, Color color)
{
    using Enumerators = std::reflect::get_enumerators_t<reflexpr(Color)>;
    auto helper = [&]<std::size_t ...i>(std::index_sequence<i...>)
    {
        ([&] {
            using Enumerator = std::reflect::get_element_t<i, Enumerators>;
            if (color == std::reflect::get_constant_v<Enumerator>)
            {
                out << std::reflect::get_name_v(Enumerator);
            }
        }(), ...);
    };

    constexpr std::size_t N = std::reflect::get_size_v<Enumerators>;
    helper(std::make_index_sequence<N>{});
    return out;
}
```

---

## Other features

* Get source line/column of a type definition.
* Get the name of an entity as a string.
* Get member types/enums/etc of a type.
* Get base classes of a type.
* Get whether variable is `static`/`constexpr`.
* Get properties of base classes: `virtual`/`public`/etc

More features planned in the future:
* Reflecting functions: P0670
* Plans to reflect on arbitrary expressions too.

---

## Final syntax is not settled yet: P0953

Plan to rebase on top of `constexpr` notation.

```cpp
struct Foo
{
    int x;
    long y;
}

constexpr std::reflect::Record meta_foo = reflexpr(Foo);
constexpr std::vector members = meta_foo.get_data_members();

constexpr std::reflect::RecordMember meta_x = members[0];
constexpr bool is_public = meta_x.is_public();
constexpr std::reflect::Type x = meta_x.get_reflected_type();

using X = unreflexpr(x); // This is int!
```
Need `unreflexpr` to translate from metadata back to type system.

---

## Another example: Print an enum

```cpp
enum class Color { RED, GREEN, BLUE, YELLOW, PURPLE };

std::ostream& operator<<(std::ostream& out, Color color)
{
    constexpr std::vector enumerators = reflexpr(Color).get_enumerators();
    for... (constexpr std::reflect:Enumerator enumerator : enumerators)
    {
        if (color == enumerator.get_constant())
        {
            out << enumerator.get_name();
        }
    }
    return out;
}
```

---

## `for...`? P0589

Not a normal `for` loop.
Expands roughly to:
```cpp
std::ostream& operator<<(std::ostream& out, Color color)
{
    constexpr std::vector enumerators = reflexpr(Color.get_enumerators();
    {
        constexpr std::reflect::Enumerator enumerator = enumerators[0];
        if (color == enumerator.get_constant())
        {
            out << enumerator.get_name();
        }
    }
    {
        constexpr std::reflect::Enumerator enumerator = enumerators[1];
        if (color == enumerator.get_constant())
        {
            out << enumerator.get_name();
        }
    }
    // ...
    return out;
}
```
so you can have a different type at each step of the `for...` loop.

---

## Status of reflection

1. Reflection TS figures out the compiler query API.
2. Will rebase on top of the `constexpr` work.
3. Aim is to write normal-looking C++ code.

---

# Step 3: Code Injection

Alternatives considered in P0633:

1. Raw string injection.
2. Programmatic API.
3. Token-sequence injection.

Go to Herb's keynote "Thoughts on a more powerful and simpler C++ (5 of N)": <https://www.youtube.com/watch?v=80BZxujhY38>

First half is on CPPX, second on Metaclasses.

---

## What can we hope for?

Optimistic prediction:

C++ 20

* More `constexpr`:
    * `std::vector`, `std::string`, `std::map`?
    * Language features required by those.
* `<experimental/reflect>` (syntax TBD).

C++ 23

* Even more `constexpr`.
* Some code injection mechanism.
* `<reflect>` based on `constexpr`.

---

## Associate data with locks, take 1 (good)

Observation: If we knew which mutex covered which data, we could diagnose "oops, forgot to lock" and "oops, took the wrong lock".

A manual discipline to group data with its mutex:

```cpp
struct MyData {
    vector<int>& v()        { assert(m_.is_held() ); return v_; }
    Widget*&     w()        { assert(m_.is_held() ); return w_; }
    void         lock()     { m_.lock(); }
    bool         try_lock() { return m_.try_lock(); }
    void         unlock()   { m_.unlock(); }

private:
    vector<int> v_;
    Widget*     w_;
    mutex_type  m_;
}
```

* Resonable migration from existing source (perhaps just add "()").
* Repetitive: It would be nice to automate the boring parts...

---

## Step 1: A testable mutex

Many mutex types (including `std::mutex`) don't provide a way to ask "have I acquired this?"

A simple wrapper to the rescue:

```cpp
template<typename Mutex>
class TestableMutex {
public:
    void lock()     { m.lock(); id = this_thread::get_id(); }
    void unlock()   { id = thread::id(); m.unlock(); }
    bool try_lock() {
        bool b = m.try_lock();
        if (b)
            id = this_thread::get_id();
        return b;
    }
    bool is_held()  { return id == this_thread::get_id(); }
private:
    Mutex m;
    atomic<thread::id> id;
} // for recursive mutexes, can also add a count.
```

---

## Step 2: Innocence by association

Boilerplate (sorry for the macros)
```cpp
#define GUARDED_WITH(MutType) \
    public: void lock()     { mut_.lock(); } \
    public: bool try_lock() { mut_.try_lock(); } \
    public: void unlock()   { mut_.unlock(); } \
    private: TestableMutex<MutType> mut_;

// Have to use token pasting to make a different member name for the private member than for the accessor.
// Otherwise the user would have to specify two names - one for the the public name and the other for the private name.
#define GUARDED_WITH(Type,name) \
    public: Type& name() { assert(mut_.is_held()); return name##_; } \
    private: Type name##_;
```

Then we associate data with a mutex more easily:

```cpp
// Have to refer to the macro that was declared earlier 
struct MyData {
    GUARDED_WITH(mutex_type);
    GUARDED_MEMBER(vector<int>, v);
    GUARDED_MEMBER(Widget*, w);
}
```

---

## Error detection, the sooner, the better

Now we can find many latency race conditions automatically and deterministically at test time (vast improvement over intermittent timing-dependent customer bugs).

```cpp
MyData data1 = ..., data2 = ...;
vector<int>* sneaky = nullptr;

data1.v().push_back(10); // error: will assert
data2.w()->ProcessYearEnd(); // error: will assert
{ // enter critical section
    lock_guard<MyData> hold(data1); // can treat it as a lockable object
    data1.v().push_back(10); // ok, locked
    data2.w()->ProcessYearEnd(); // error: will assert
    sneaky = &data1.v(); // ok, but avoid doing this
}
sneaky->push_back(10); // error, but won't assert
```

Catches both "oops, forgot to lock" and "oops, took the wrong lock".

---

## Using a `guarded<M>` metaclass

P0707R4

```cpp
// Today a metaclass is defined as template<type T> (T source)
// Additional template parameter M which is the mutex type
template<typename M, typename T>
constexpr void guarded(T source) {
    guarded_with<M>; // generates lock(), try_lock(), unlock() and the mutex of type M.

    // for every member variable
    for... (auto o : source.member_variables()) {
        // create an accessor and a private variable with a suffix name
        guarded_member(o.type(), o.name());
    }

    // Checks at compile time that you're not guarding a class with no data members.
    compiler.require(source.member_functions().siz
        "a guarded class may not have member funct"
        "release (in the next release, we may supp"
        "synchronised functions)");
};

// User code: using a metaclass to write a type
class(guarded<mutex_type>) MyData
{
    vector<int> v;
    Widget* w;
};
```

---

# Features

- **Slides are written in Markdown.**
- Cross-platform. Supports Windows, Mac, and Linux
- Live Preview with 3 modes
- Slide themes (`default`, `gaia`) and custom background images
- Supports emoji :heart:
- Render maths in your slides
- Export your slides to PDF

---

# How to write slides?

Split slides by horizontal ruler `---`. It's very simple.

```md
# Slide 1

foobar

---

# Slide 2

foobar
```

> *Notice: Ruler (`<hr>`) is not displayed in Marp.*

---

# Directives

Marp's Markdown has extended directives to affect slides.

Insert HTML comment as below:
```html
<!-- {directive_name}: {value} -->
```

```html
<!--
{first_directive_name}:  {value}
{second_directive_name}: {value}
...
-->
```
---

## Global Directives

### `$theme`

Changes the theme of all the slides in the deck. You can also change from `View -> Theme` menu.

```
<!-- $theme: gaia -->
```

|Theme name|Value|Directive|
|:-:|:-:|:-|
|***Default***|default|`<!-- $theme: default -->`
|**Gaia**|gaia|`<!-- $theme: gaia -->`


---

### `$width` / `$height`

Changes width and height of all the slides.

You can use units: `px` (default), `cm`, `mm`, `in`, `pt`, and `pc`.

```html
<!-- $width: 12in -->
```

### `$size`

Changes slide size by presets.

Presets: `4:3`, `16:9`, `A0`-`A8`, `B0`-`B8` and suffix of `-portrait`.

```html
<!-- $size: 16:9 -->
```

<!--
$size: a4

Example is here. Global Directive is enabled in anywhere.
It apply the latest value if you write multiple same Global Directives.
-->

---

## Page Directives

The page directive would apply to the  **current page and the following pages**.
You should insert it *at the top* to apply it to all slides.

### `page_number`

Set `true` to show page number on slides. *See lower right!*

```html
<!-- page_number: true -->
```

<!--
page_number: true

Example is here. Pagination starts from this page.
If you use multi-line comment, directives should write to each new lines.
-->

---

### `template`

Set to use template of theme.

The `template` directive just enables that using theme supports templates.

```html
<!--
$theme: gaia
template: invert
-->

Example: Set "invert" template of Gaia theme.
```

---

### `footer`

Add a footer to the current slide and all of the following slides

```html
<!-- footer: This is a footer -->
```

Example: Adds "This is a footer" in the bottom of each slide

---

### `prerender`

Pre-renders a slide, which can prevent issues with very large background images.

```html
<!-- prerender: true -->
```

---

## Pro Tips

#### Apply page directive to current slide only

Page directive can be selectively applied to the current slide by prefixing the page directive with `*`.

```
<!-- *page_number: false -->
<!-- *template: invert -->
```

<!--
*page_number: false

Example is here.
Page number is not shown in current page, but it's shown on later pages.
-->

---

#### Slide background Images

You can set an image as a slide background.

```html
![bg](mybackground.png)
```

Options can be provided after `bg`, for example `![bg original](path)`.

Options include:

- `original` to include the image without any effects
- `x%` to include the  image at `x` percent of the slide size

Include multiple`![bg](path)` tags to stack background images horizontally.

![bg](images/background.png)

---

#### Maths Typesetting

Mathematics is typeset using the `KaTeX` package. Use `$` for inline maths, such as $ax^2+bc+c$, and `$$` for block maths:

$$I_{xx}=\int\int_Ry^2f(x,y)\cdot{}dydx$$

```html
This is inline: $ax^2+bx+c$, and this is block:

$$I_{xx}=\int\int_Ry^2f(x,y)\cdot{}dydx$$

```

---

## Enjoy writing slides! :+1:

### https://github.com/yhatt/marp

Copyright &copy; 2016 [Yuki Hattori](https://github.com/yhatt)
This software released under the [MIT License](https://github.com/yhatt/marp/blob/master/LICENSE).